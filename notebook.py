# -*- coding: utf-8 -*-
"""SistemRekomendasiAnime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1olgnvtuUMGBQZcEpbfXdsKiEVrRXUvOp

# Data Understanding

**Import Library**
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from collections import Counter

"""**Load Data**"""

df = pd.read_csv('Anime.csv')
df

"""**Data Info**"""

df.info()

"""1. ID: ID unik anime di MyAnimeList.net
2. Title: Judul asli dari anime
3. Synonyms: Nama lain (sinonim) dari anime
4. Japanese: Judul anime dalam bahasa Jepang
5. English: Judul anime dalam bahasa Inggris
6. Synopsis: Ringkasan atau sinopsis dari anime
7. Type: Tipe anime (misalnya, TV, Movie, OVA, ONA, Special, Music)
8. Episodes: Jumlah episode dalam anime
9. Status: Status penayangan anime (belum tayang, sedang tayang, sudah selesai tayang)
10. Start_Aired: Tanggal atau tahun mulai tayang anime
11. End_Aired: Tanggal atau tahun selesai tayang anime
23. Premiered: Musim tayang perdana anime
13. Broadcast: Jadwal siaran anime
14. Producers: Daftar produser anime
15. Licensors: Daftar pemegang lisensi anime
16. Studios: Daftar studio animasi yang memproduksi anime
17. Source: Sumber materi asli anime
18. Genres: Daftar genre anime
19. Themes: Daftar tema-tema yang ada dalam anime
20. Demographics: Target demografi penonton anime
21. Duration_Minutes: Durasi total per menit untuk setiap episode anime
22. Rating: Batasan usia penonton yang direkomendasikan untuk anime
23. Score: Skor rata-rata anime yang diberikan oleh pengguna di MyAnimeList.net
24.Scored_Users: Jumlah pengguna yang memberikan skor pada anime
25. Ranked: Peringkat anime berdasarkan skor
26. Popularity: Peringkat anime berdasarkan popularitas (jumlah pengguna yang menambahkan ke daftar mereka)
27. Members: Jumlah pengguna yang telah menambahkan anime ke daftar tontonan mereka
28. Favorites: Jumlah pengguna yang menandai anime sebagai favorit mereka

**Statistik Deskriptif**
"""

df.describe(include='all')

"""Output dari df.describe() memberikan statistik deskriptif penting untuk kolom-kolom numerik dalam DataFrame df. Statistik ini meliputi:

- count: Jumlah total data (non-null)
- std: Standar deviasi, mengukur penyebaran data. Harga rumah memiliki standar deviasi yang sangat tinggi, menandakan variasi harga yang besar.
- min: Nilai minimum untuk setiap kolom.
- 25%: Kuartil pertama (nilai di mana 25% data berada di bawahnya).
- 50%: Median atau kuartil kedua (nilai tengah data).
- 75%: Kuartil ketiga (nilai di mana 75% data berada di bawahnya).
- max: Nilai maksimum untuk setiap kolom.

**Missing Value**
"""

df.isnull().sum()

"""Terdapat missing value pada kolom:
- Episodes	547
- Duration_Minutes	599
- Rating	545
- Score	6898
- Scored_Users	6898
- Ranked	1924

"""

jumlah_duplikat = df.duplicated().sum()
jumlah_duplikat

"""Tidak ada jumlah data duplikat

**Matriks Korelasi**
"""

correlation_matrix = df.corr(numeric_only=True) # Pastikan hanya kolom numerik yang dihitung korelasinya
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matriks Korelasi Antar Fitur Numerik')
plt.show()

"""1. ID: Tidak berkorelasi signifikan dengan fitur lain.
2. Skor:
- Berkorelasi positif sedang dengan jumlah pemberi skor, anggota, dan favorit.
- Berkorelasi negatif sangat kuat dengan peringkat dan popularitas.
3. Jumlah Pemberi Skor:
- Berkorelasi positif sangat kuat dengan jumlah anggota dan favorit.
- Berkorelasi negatif sedang dengan peringkat dan popularitas.
4. Peringkat:
- Berkorelasi positif sangat kuat dengan popularitas.
- Berkorelasi negatif sedang dengan jumlah anggota dan favorit.
5. Popularitas:
- Berkorelasi positif kuat dengan jumlah anggota dan sedang dengan favorit.
6. Jumlah Anggota: Berkorelasi positif kuat dengan jumlah favorit.
7. Jumlah Episode dan Durasi: Korelasinya lemah dengan fitur lain.
8. Implikasi Rekomendasi:
- Fitur berkorelasi tinggi mungkin memberikan informasi redundan.
- Skor, jumlah pemberi skor, anggota, dan favorit adalah indikator popularitas dan kualitas.
- Jumlah episode dan durasi memberikan informasi yang berbeda.
9. Kesimpulan: Heatmap visualisasikan hubungan linier, penting untuk pemilihan fitur dan pemahaman data, namun tidak mencerminkan hubungan non-linier atau sebab-akibat.

**Distribusi Tipe Anime**
"""

plt.figure(figsize=(10, 6))
sns.countplot(data=df, y='Type', order=df['Type'].value_counts().index)
plt.title('Distribusi Tipe Anime')
plt.xlabel('Jumlah')
plt.ylabel('Tipe')
plt.show()

"""Distribusi tipe anime terbanyak adalah TV

**Distribusi Rating Anime**
"""

plt.figure(figsize=(12, 7))
sns.countplot(data=df, y='Rating', order=df['Rating'].value_counts().index)
plt.title('Distribusi Rating Anime')
plt.xlabel('Jumlah')
plt.ylabel('Rating')
plt.show()

"""Rating terbanyak adalah PG-13 (Teens 13 or older)

**Top 10 Genre Terpopuler**
"""

genre_counts = Counter()
for genres in df['Genres'].dropna():
    genre_counts.update(genres.split(', '))

top_10_genres = genre_counts.most_common(10)
genres, counts = zip(*top_10_genres)

plt.figure(figsize=(12, 7))
sns.barplot(x=list(counts), y=list(genres))
plt.title('Top 10 Genre Anime')
plt.xlabel('Jumlah Anime')
plt.ylabel('Genre')
plt.show()
print(f"Insight: Genre terpopuler adalah {genres[0]}.")

"""**Distribusi Status Penayangan**"""

plt.figure(figsize=(10, 6))
sns.countplot(data=df, y='Status', order=df['Status'].value_counts().index)
plt.title('Distribusi Status Penayangan Anime')
plt.xlabel('Jumlah Anime')
plt.ylabel('Status')
plt.show()

"""Status penayangan terbanyak adalah selesai tayang

**Distribusi Sumber**
"""

plt.figure(figsize=(10, 6))
sns.countplot(data=df, y='Source', order=df['Source'].value_counts().index)
plt.title('Distribusi Sumber Anime')
plt.xlabel('Jumlah Anime')
plt.ylabel('Sumber')
plt.show()

"""Sumber anime terbanyak adalah original

**Top 10 Studio**
"""

studios_counts = Counter()
for studios_str in df['Studios'].dropna():
    studios_counts.update(studios_str.split(', '))

top_10_studios = studios_counts.most_common(10)
studios, counts = zip(*top_10_studios)

plt.figure(figsize=(12, 7))
sns.barplot(x=list(counts), y=list(studios))
plt.title('Top 10 Studio Anime')
plt.xlabel('Jumlah Anime')
plt.ylabel('Studio')
plt.show()

"""Masih banyak unknown studio, tetapi studio pembuat anime terbanyak adalah Toel Animation

**Top 10 Tema Anime**
"""

themes_counts = Counter()
for themes_str in df['Themes'].dropna():
    themes_counts.update(themes_str.split(', '))

top_10_themes = themes_counts.most_common(10)
themes, counts = zip(*top_10_themes)

plt.figure(figsize=(12, 7))
sns.barplot(x=list(counts), y=list(themes))
plt.title('Top 10 Tema Anime')
plt.xlabel('Jumlah Anime')
plt.ylabel('Tema')
plt.show()

"""Masih banyak unknown tema, tetapi tema anime terbanyak adalah music

# Data Preparation

**Menangani Missing Value**
"""

# Mengisi missing values pada 'Episodes' dengan median per 'Type'
df['Episodes'] = df.groupby('Type')['Episodes'].transform(lambda x: x.fillna(x.median()))

# Mengisi missing values pada 'Duration_Minutes' dengan median keseluruhan
df['Duration_Minutes'].fillna(df['Duration_Minutes'].median(), inplace=True)

# Mengisi missing values pada 'Rating' dengan modus
df['Rating'].fillna(df['Rating'].mode()[0], inplace=True)

# Mengisi missing values pada 'Score' dan 'Scored_Users' dengan 0 (asumsi belum dinilai)
df['Score'].fillna(0, inplace=True)
df['Scored_Users'].fillna(0, inplace=True)

# Mengisi missing values pada 'Ranked' dengan nilai di luar rentang (misalnya, -1)
df['Ranked'].fillna(-1, inplace=True)

# Verifikasi jumlah missing values setelah penanganan
print(df[['Episodes', 'Duration_Minutes', 'Rating', 'Score', 'Scored_Users', 'Ranked']].isnull().sum())

"""**Cek Missing Value setelah Cleaning**"""

df.isnull().sum()

"""Data terbebas dari missing value

**Ekstraksi Fitur Tf Idf**
"""

# Feature Extraction
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['Genres'].fillna('')) # Mengatasi Nilai NaN

"""# Modeling and Result

**Content-Based Filtering with Cosine Similarity**
"""

# Calculate Cosine Similarity
cosine_sim_content = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Recommendation Function
def get_content_based_recommendations(title, cosine_sim=cosine_sim_content, df=df, top_n=5):
    indices = pd.Series(df.index, index=df['Title']).drop_duplicates()
    try:
        idx = indices[title]
        sim_scores = list(enumerate(cosine_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
        sim_scores = sim_scores[1:top_n+1]
        anime_indices = [i[0] for i in sim_scores]
        return df['Title'].iloc[anime_indices].tolist() # Return as list for easier evaluation
    except KeyError:
        print(f"Anime '{title}' tidak ditemukan.")
        return []

# --- Top-N Recommendation dan Evaluasi ---
anime_to_recommend_for = "Naruto"
top_k = 5
content_based_recommendations = get_content_based_recommendations(anime_to_recommend_for, top_n=top_k)
print(f"\nTop {top_k} Rekomendasi Content-Based untuk '{anime_to_recommend_for}':")
print(content_based_recommendations)

"""# Evaluation"""

# Fungsi Evaluasi
def precision_at_k(relevant_items, recommended_items, k=5):
    """Menghitung Precision@K."""
    if not recommended_items:
        return 0.0
    top_k = recommended_items[:k]
    relevant_in_top_k = [item for item in top_k if item in relevant_items]
    return len(relevant_in_top_k) / min(k, len(recommended_items))

def recall_at_k(relevant_items, recommended_items, k=5):
    """Menghitung Recall@K."""
    if not relevant_items:
        return 0.0
    top_k = recommended_items[:k]
    relevant_in_top_k = [item for item in top_k if item in relevant_items]
    return len(relevant_in_top_k) / len(relevant_items)

def f1_score_at_k(precision, recall):
    """Menghitung F1-score@K."""
    if precision + recall == 0:
        return 0.0
    return 2 * (precision * recall) / (precision + recall)

# mendefinisikan secara manual atau berdasarkan data interaksi pengguna
# item mana yang dianggap relevan untuk 'Naruto'.
relevant_for_naruto = ["Hunter x Hunter (2011)", "Naruto: Shippuuden", "One Piece", "Nanatsu no Taizai", "Bleach"]

# Evaluasi
precision = precision_at_k(relevant_for_naruto, content_based_recommendations, k=top_k)
recall = recall_at_k(relevant_for_naruto, content_based_recommendations, k=top_k)
f1 = f1_score_at_k(precision, recall)

print(f"\nEvaluasi Content-Based Filtering untuk '{anime_to_recommend_for}' ")
print(f"Precision@{top_k}: {precision}")
print(f"Recall@{top_k}: {recall}")
print(f"F1-score@{top_k}: {f1}")

"""Semua rekomendasi (5/5) yang diberikan sistem termasuk dalam daftar anime relevan yang  didefinisikan.

Ini adalah kondisi ideal, artinya sistem rekomendasi bekerja dengan sangat baik untuk kasus ini.
"""